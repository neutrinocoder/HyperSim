<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rainforest Ecosystem Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --dark-bg: #1a1a1a;
            --medium-bg: #2a2a2a;
            --light-bg: #333;
            --text-color: #e0e0e0;
            --accent-green: #28a745;
            --accent-blue: #007bff;
        }
        html {
            height: 100%;
        }
        body {
            min-height: 100vh; /* Use min-height to allow content to expand */
            margin: 0;
            padding: 0;
            background-color: var(--dark-bg);
            font-family: 'Arial', sans-serif;
            color: var(--text-color);
            display: flex; /* Use flexbox for centering */
            flex-direction: column;
            align-items: center;
            padding: 20px; /* Add some padding for small screens */
            box-sizing: border-box;
            overflow-y: auto; /* Enable vertical scrolling for the whole page */
        }
        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 100%;
            max-width: 1000px;
        }
        #canvas-container { 
            flex-shrink: 0; 
            width: 100%;
        }
        canvas {
            display: block;
            border: 1px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(40, 180, 99, 0.3);
            max-width: 100%;
            height: auto; /* Adjust height automatically */
        }
        .controls {
            background-color: var(--medium-bg);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .info-display {
            font-size: 0.9em;
            color: var(--text-color);
            background-color: var(--light-bg);
            padding: 10px 15px;
            border-radius: 6px;
            width: 95%;
            text-align: center;
            min-height: 20px;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px 20px;
            width: 100%;
            max-width: 600px;
        }
        .input-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        label { font-size: 1em; color: #ccc; }
        input[type="number"], input[type="range"] {
            background-color: #444; border: 1px solid #666; color: #fff; border-radius: 4px; padding: 5px;
        }
        input[type="number"] { width: 60px; }
        button {
            color: white; border: none; padding: 12px 25px; border-radius: 5px;
            font-size: 1.1em; cursor: pointer; transition: background-color 0.3s;
        }
        #main-button { background-color: var(--accent-green); }
        #main-button:hover { background-color: #218838; }
        .hidden { display: none; }
        .mode-switch { display: flex; gap: 10px; align-items: center; }
    </style>
</head>
<body>
    <main>
        <h1>Rainforest Ecosystem Simulator</h1>
        <div id="canvas-container"></div>
        <div class="controls">
            <div class="info-display" id="info-display">Configure populations and press Start.</div>

            <div class="mode-switch">
                <label>Normal Mode</label>
                <input type="checkbox" id="mode-toggle">
                <label>Hyper Mode</label>
            </div>

            <div class="settings-grid">
                <div class="input-group"><label for="initial-trees">Trees:</label><input type="number" id="initial-trees" value="100" min="0"></div>
                <div class="input-group"><label for="initial-butterflies">Butterflies:</label><input type="number" id="initial-butterflies" value="40" min="0"></div>
                <div class="input-group"><label for="initial-frogs">Frogs:</label><input type="number" id="initial-frogs" value="15" min="0"></div>
                <div class="input-group"><label for="initial-snakes">Snakes:</label><input type="number" id="initial-snakes" value="5" min="0"></div>
                <div class="input-group"><label for="initial-hawks">Hawks:</label><input type="number" id="initial-hawks" value="2" min="0"></div>
            </div>

            <div id="normal-controls">
                <label for="day-length-slider">Day Length: <span id="day-length-value">10</span>s</label>
                <input type="range" id="day-length-slider" min="1" max="30" value="10">
            </div>
            <div id="hyper-controls" class="hidden">
                <div class="input-group">
                    <label for="years-input">Simulate for:</label>
                    <input type="number" id="years-input" value="10" min="1"> <span>Years</span>
                </div>
            </div>

            <button id="main-button">Start Simulation</button>
        </div>
    </main>

    <script>
    // --- QuadTree (Helper for Optimization) ---
    class Point { constructor(x, y, userData) { this.x = x; this.y = y; this.userData = userData; } }
    class Rectangle {
        constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
        contains(point) { return (point.x >= this.x - this.w && point.x <= this.x + this.w && point.y >= this.y - this.h && point.y <= this.y + this.h); }
        intersects(range) { return !(range.x - range.w > this.x + this.w || range.x + range.w < this.x - this.w || range.y - range.h > this.y + this.h || range.y + range.h < this.y - this.h); }
    }
    class QuadTree {
        constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.points = []; this.divided = false; }
        subdivide() {
            let { x, y, w, h } = this.boundary;
            let hw = w / 2, hh = h / 2;
            this.northeast = new QuadTree(new Rectangle(x + hw, y - hh, hw, hh), this.capacity); this.northwest = new QuadTree(new Rectangle(x - hw, y - hh, hw, hh), this.capacity);
            this.southeast = new QuadTree(new Rectangle(x + hw, y + hh, hw, hh), this.capacity); this.southwest = new QuadTree(new Rectangle(x - hw, y + hh, hw, hh), this.capacity);
            this.divided = true;
        }
        insert(point) {
            if (!this.boundary.contains(point)) return false;
            if (this.points.length < this.capacity) { this.points.push(point); return true; }
            if (!this.divided) this.subdivide();
            return this.northeast.insert(point) || this.northwest.insert(point) || this.southeast.insert(point) || this.southwest.insert(point);
        }
        query(range, found = []) {
            if (!this.boundary.intersects(range)) return found;
            for (let p of this.points) { if (range.contains(p)) found.push(p); }
            if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); }
            return found;
        }
    }

    // --- BASE ANIMAL CLASS ---
    class Animal {
        constructor(x, y, gender) {
            this.position = createVector(x, y); this.velocity = p5.Vector.random2D(); this.acceleration = createVector(); this.gender = gender; this.foodEaten = 0;
        }
        seek(target) { let desired = p5.Vector.sub(target.position, this.position); desired.setMag(this.maxSpeed); return p5.Vector.sub(desired, this.velocity).limit(this.maxForce); }
        flee(target) { return this.seek(target).mult(-1.5); }
        applyBehaviors(preyQT, predatorQT, mates) {
             let searchArea = new Rectangle(this.position.x, this.position.y, this.searchRadius, this.searchRadius);
             let predatorsNearby = predatorQT ? predatorQT.query(searchArea) : [];
             if (predatorsNearby.length > 0) { this.acceleration.add(this.flee(predatorsNearby[0].userData)); }
             else if (this.foodEaten > 0 && mates.length > 0) { this.acceleration.add(this.seek(mates[0])); }
             else { let preyNearby = preyQT ? preyQT.query(searchArea) : []; if(preyNearby.length > 0) { this.acceleration.add(this.seek(preyNearby[0].userData)); } }
        }
        update() { this.velocity.add(this.acceleration); this.velocity.limit(this.maxSpeed); this.position.add(this.velocity); this.acceleration.mult(0); this.boundaries(); }
        boundaries() { if (this.position.x < 0) this.position.x = width; if (this.position.x > width) this.position.x = 0; if (this.position.y < 0) this.position.y = height; if (this.position.y > height) this.position.y = 0; }
    }

    // --- ECOSYSTEM SPECIES with NEW VISUALS ---
    class Tree { constructor(x, y) { this.position = createVector(x,y); this.size=random(10,20); } display() { noStroke(); fill('green'); ellipse(this.position.x,this.position.y,this.size,this.size);}}
    class Butterfly extends Animal { constructor(x,y,g) { super(x,y,g); this.maxSpeed=2; this.maxForce=0.1; this.size=8; this.searchRadius=100; } display() { noStroke(); fill('pink'); ellipse(this.position.x, this.position.y, this.size, this.size); }}
    class Frog extends Animal { constructor(x,y,g) { super(x,y,g); this.maxSpeed=2.5; this.maxForce=0.2; this.size=12; this.searchRadius=120; } display() { noStroke(); fill('darkgreen'); ellipse(this.position.x, this.position.y, this.size, this.size); }}
    class Snake extends Animal { constructor(x,y,g) { super(x,y,g); this.maxSpeed=2; this.maxForce=0.15; this.size=15; this.searchRadius=150; } display() { push(); stroke('yellow'); strokeWeight(4); line(this.position.x, this.position.y, this.position.x - this.velocity.x * this.size, this.position.y - this.velocity.y * this.size); pop(); }}
    class Hawk extends Animal { constructor(x,y,g) { super(x,y,g); this.maxSpeed=3.5; this.maxForce=0.25; this.size=12; this.searchRadius=250; } display() { push(); translate(this.position.x,this.position.y); rotate(this.velocity.heading()+PI/2); noStroke(); fill('saddlebrown'); beginShape(); vertex(0, -this.size); vertex(-this.size/2, this.size); vertex(this.size/2, this.size); endShape(CLOSE); pop(); }}
    
    // --- Global Simulation State ---
    let isSimulating = false, isPaused = false;
    let dayCounter = 0, dayStartTime, pauseEndTime;
    let populations = { trees: [], butterflies: [], frogs: [], snakes: [], hawks: [] };
    let simMode = 'normal'; // 'normal' or 'hyper'
    let dayLengthMillis = 10000;
    let hyperSimTotalDays = 0;

    // --- Global UI Element Variables ---
    let mainButton, infoDisplay, normalControls, hyperControls, modeToggle, dayLengthSlider, dayLengthValue, yearsInput;
    let initialInputs = {};

    // --- UI & Main Logic ---
    function setup() {
        // Correct canvas sizing for responsiveness
        let canvasContainer = select('#canvas-container');
        let canvasWidth = canvasContainer.width;
        let canvasHeight = windowHeight * 0.5; // Maintain a reasonable height
        let canvas = createCanvas(canvasWidth, canvasHeight);
        canvas.parent('canvas-container');

        initializeUI();
        updateControlsView();
        noLoop();
    }
    
    function initializeUI() {
        mainButton = select('#main-button');
        infoDisplay = select('#info-display');
        normalControls = select('#normal-controls');
        hyperControls = select('#hyper-controls');
        modeToggle = select('#mode-toggle');
        dayLengthSlider = select('#day-length-slider');
        dayLengthValue = select('#day-length-value');
        yearsInput = select('#years-input');
        
        initialInputs = {
            trees: select('#initial-trees'), butterflies: select('#initial-butterflies'), frogs: select('#initial-frogs'), snakes: select('#initial-snakes'), hawks: select('#initial-hawks')
        };
        
        mainButton.mousePressed(toggleSimulation);
        modeToggle.changed(() => { simMode = modeToggle.elt.checked ? 'hyper' : 'normal'; updateControlsView(); });
        dayLengthSlider.input(() => { dayLengthMillis = dayLengthSlider.value() * 1000; dayLengthValue.html(dayLengthSlider.value()); });
    }
    
    function updateControlsView() {
        if (simMode === 'hyper') {
            normalControls.addClass('hidden');
            hyperControls.removeClass('hidden');
        } else {
            normalControls.removeClass('hidden');
            hyperControls.addClass('hidden');
        }
    }

    function toggleSimulation() {
        isSimulating = !isSimulating;
        if(isSimulating) {
            mainButton.html('Stop Simulation');
            resetSimulation();
            loop();
        } else {
            mainButton.html('Start Simulation');
            noLoop();
        }
    }
    
    function resetSimulation() {
        dayCounter = 0; isPaused = false;
        dayStartTime = millis();
        populations = { trees: [], butterflies: [], frogs: [], snakes: [], hawks: [] };
        const createPopulation = (arr, Cls, count) => { for(let i=0; i<count; i++) arr.push(new Cls(random(width), random(height), i%2===0?'male':'female')); };
        createPopulation(populations.trees, Tree, int(initialInputs.trees.value()));
        createPopulation(populations.butterflies, Butterfly, int(initialInputs.butterflies.value()));
        createPopulation(populations.frogs, Frog, int(initialInputs.frogs.value()));
        createPopulation(populations.snakes, Snake, int(initialInputs.snakes.value()));
        createPopulation(populations.hawks, Hawk, int(initialInputs.hawks.value()));
    }
    
    function draw() {
        background('#87ceeb');
        if (simMode === 'normal') {
            const timeElapsed = millis() - dayStartTime;
            if(!isPaused && timeElapsed > dayLengthMillis) { isPaused=true; pauseEndTime=millis()+1500; endOfDay(); }
            if(isPaused && millis() > pauseEndTime) { dayCounter++; dayStartTime=millis(); isPaused=false; }
            if(!isPaused) runSimulationStep();
        } else { // Hyper mode
             hyperSimTotalDays = int(yearsInput.value()) * 365;
             let daysPerFrame = 10;
             for(let i=0; i<daysPerFrame; i++) {
                 if(dayCounter > hyperSimTotalDays) { toggleSimulation(); return; }
                 runSimulationStep(false); endOfDay(); dayCounter++;
             }
        }
        
        if (simMode === 'normal' || !isSimulating) {
            Object.values(populations).flat().forEach(o => o.display());
        }

        // Only show the "Day X Ended" pause message if the sim is paused AND still running.
        if(isPaused && isSimulating) { 
            fill(255,200);
            rectMode(CENTER);
            rect(width/2,height/2,450,100,10);
            fill(0);textAlign(CENTER,CENTER);
            textSize(24);
            text(`Day ${dayCounter} Ended`,width/2,height/2);
        }
        updateInfoDisplay();
    }
    
    function runSimulationStep(shouldUpdateBehaviors = true) {
        let qTrees = {};
        for (const key in populations) {
            qTrees[key] = new QuadTree(new Rectangle(width / 2, height / 2, width / 2, height / 2), 4);
            for (const item of populations[key]) {
                qTrees[key].insert(new Point(item.position.x, item.position.y, item));
            }
        }

        if (shouldUpdateBehaviors) {
            const findMates = (speciesArray, self) => speciesArray.filter(a => a.gender !== self.gender && a.foodEaten > 0);
            populations.butterflies.forEach(o => { o.applyBehaviors(qTrees.trees, qTrees.frogs, findMates(populations.butterflies, o)); o.update(); });
            populations.frogs.forEach(o => { o.applyBehaviors(qTrees.butterflies, qTrees.snakes, findMates(populations.frogs, o)); o.update(); });
            populations.snakes.forEach(o => { o.applyBehaviors(qTrees.frogs, qTrees.hawks, findMates(populations.snakes, o)); o.update(); });
            populations.hawks.forEach(o => { o.applyBehaviors(qTrees.snakes, null, findMates(populations.hawks, o)); o.update(); });
        }
        
        handleInteractions();
    }

    function handleInteractions() {
        const predation = (predators, prey) => {
            for(let i = predators.length - 1; i>=0; i--) {
                for(let j = prey.length-1; j>=0; j--) {
                    if(predators[i].position.dist(prey[j].position) < (predators[i].size + prey[j].size) / 2) {
                        prey.splice(j,1); predators[i].foodEaten++; return;
                    }
                }
            }
        };
        predation(populations.butterflies, populations.trees);
        predation(populations.frogs, populations.butterflies);
        predation(populations.snakes, populations.frogs);
        predation(populations.hawks, populations.snakes);
    }
    
    function endOfDay() {
        const reproduce = (speciesArray, SpeciesClass) => {
            const newBabies=[]; let males=speciesArray.filter(a=>a.gender==='male'&&a.foodEaten>0); let females=speciesArray.filter(a=>a.gender==='female'&&a.foodEaten>0);
            let pairings=min(males.length,females.length);
            for(let i=0;i<pairings;i++){ let p1=males[i], p2=females[i]; if(p1.position.dist(p2.position)<30){let pos=p5.Vector.add(p1.position,p2.position).div(2);newBabies.push(new SpeciesClass(pos.x,pos.y,random()>0.5?'male':'female'));}}
            speciesArray.push(...newBabies); speciesArray.forEach(a=>a.foodEaten=0);
        };
        reproduce(populations.butterflies,Butterfly); reproduce(populations.frogs,Frog); reproduce(populations.snakes,Snake); reproduce(populations.hawks,Hawk);
        
        for(let i=0;i<5;i++) populations.trees.push(new Tree(random(width),random(height)));
        if(dayCounter % 30 === 0 && populations.trees.length > 100) { populations.trees.splice(0,100); }
        
        // **FIX**: Check for extinction and provide a clear message
        let extinctSpecies = null;
        if (populations.butterflies.length === 0) extinctSpecies = "Butterflies";
        else if (populations.frogs.length === 0) extinctSpecies = "Frogs";
        else if (populations.snakes.length === 0) extinctSpecies = "Snakes";
        else if (populations.hawks.length === 0) extinctSpecies = "Hawks";

        if (extinctSpecies && isSimulating) {
            infoDisplay.html(`Ecosystem collapsed on Day ${dayCounter}: ${extinctSpecies} went extinct.`);
            toggleSimulation(); // This stops the simulation
        }
    }

    function updateInfoDisplay() {
        if (!infoDisplay) return;
        // Don't update the info display if the simulation has stopped due to extinction
        if (!isSimulating && infoDisplay.html().includes("collapsed")) {
            return;
        }
        let p = populations;
        let counts = `üå≥:${p.trees.length} | ü¶ã:${p.butterflies.length} | üê∏:${p.frogs.length} | üêç:${p.snakes.length} | ü¶Ö:${p.hawks.length}`;
        if(simMode === 'hyper' && isSimulating) {
            infoDisplay.html(`Simulating Day: ${dayCounter} / ${hyperSimTotalDays} | ${counts}`);
        } else {
            infoDisplay.html(`Day: ${dayCounter} | ${counts}`);
        }
    }

    function windowResized() {
        let canvasContainer = select('#canvas-container');
        let canvasWidth = canvasContainer.width;
        let canvasHeight = windowHeight * 0.5;
        resizeCanvas(canvasWidth, canvasHeight);
    }
    </script>
</body>
</html>
