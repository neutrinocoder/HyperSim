<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rainforest Ecosystem Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --dark-bg: #1a1a1a;
            --medium-bg: #2a2a2a;
            --light-bg: #333;
            --text-color: #e0e0e0;
            --accent-green: #28a745;
            --accent-blue: #007bff;
            --disaster-red: #dc3545;
        }
        html {
            height: 100%;
        }
        body {
            min-height: 100vh;
            margin: 0;
            padding: 0;
            background-color: var(--dark-bg);
            font-family: 'Arial', sans-serif;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 100%;
            max-width: 1000px;
        }
        #canvas-container { 
            flex-shrink: 0; 
            width: 100%;
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        canvas {
            display: block;
            border: 1px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(40, 180, 99, 0.3);
            max-width: 100%;
            height: auto;
        }
        .controls {
            background-color: var(--medium-bg);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .info-display {
            font-size: 0.9em;
            color: var(--text-color);
            background-color: var(--light-bg);
            padding: 10px 15px;
            border-radius: 6px;
            width: 95%;
            text-align: center;
            min-height: 20px;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px 20px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
        }
        .disaster-config-section {
            border: 1px solid var(--disaster-red);
            border-radius: 8px;
            padding: 15px;
            width: 100%;
        }
        .disaster-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            width: 100%;
        }
        .disaster-card {
            background-color: var(--light-bg);
            border-radius: 6px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        h3, h4 {
            grid-column: 1 / -1;
            margin: 5px 0;
            color: var(--accent-green);
            text-align: center;
        }
        .disaster-config-section h3 {
             color: var(--disaster-red);
        }
        .disaster-card h4 {
            color: #ddd;
            margin-bottom: 5px;
        }
        .input-group, .map-size-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        label { font-size: 0.9em; color: #ccc; text-align: left;}
        input[type="number"], input[type="range"], select {
            background-color: #444; border: 1px solid #666; color: #fff; border-radius: 4px; padding: 5px;
        }
        input[type="number"] { width: 60px; }
        input[type="range"] { flex-grow: 1; }
        button {
            color: white; border: none; padding: 12px 25px; border-radius: 5px;
            font-size: 1.1em; cursor: pointer; transition: background-color 0.3s;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #main-button { background-color: var(--accent-green); }
        #main-button:hover { background-color: #218838; }
        .trigger-button { background-color: var(--disaster-red); font-size: 0.8em; padding: 6px 12px; width: 100%; margin-top: 5px;}
        .trigger-button:hover:not(:disabled) { background-color: #c82333; }
        .hidden { display: none; }
        .mode-switch { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;}
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .toggle-button {
            background-color: var(--light-bg);
            padding: 8px 12px;
            font-size: 0.9em;
        }
        .toggle-button.active {
            background-color: var(--accent-blue);
        }
    </style>
</head>
<body>
    <main>
        <h1>Rainforest Ecosystem Simulator</h1>
        <div id="canvas-container"></div>
        <div class="controls">
            <div class="info-display" id="info-display">Configure populations and press Start.</div>

            <div class="mode-switch">
                <label>Normal Mode</label>
                <input type="checkbox" id="mode-toggle">
                <label>Hyper Mode</label>
                <button id="status-toggle" class="toggle-button">Show Status</button>
                <button id="trees-toggle" class="toggle-button active">Show Trees</button>
            </div>
            
            <div class="settings-grid">
                 <h3>Initial Setup</h3>
                 <div class="map-size-group">
                    <label>Map Size:</label>
                    <select id="map-size-select">
                        <option value="small">Small (1200x800)</option>
                        <option value="medium" selected>Medium (1800x1200)</option>
                        <option value="large">Large (2400x1600)</option>
                    </select>
                </div>
                <div class="input-group"><label for="initial-plants">Plants:</label><input type="number" id="initial-plants" value="100" min="0"></div>
                <div class="input-group"><label for="initial-butterflies">Butterflies:</label><input type="number" id="initial-butterflies" value="40" min="0"></div>
                <div class="input-group"><label for="initial-frogs">Frogs:</label><input type="number" id="initial-frogs" value="12" min="0"></div>
                <div class="input-group"><label for="initial-snakes">Snakes:</label><input type="number" id="initial-snakes" value="3" min="0"></div>
                <div class="input-group"><label for="initial-hawks">Hawks:</label><input type="number" id="initial-hawks" value="2" min="0"></div>
            </div>

            <div id="normal-controls">
                <label for="day-length-slider">Day Length (Speed): <span id="day-length-value">10</span>s</label>
                <input type="range" id="day-length-slider" min="1" max="30" value="10">
            </div>
            <div id="hyper-controls" class="hidden">
                <div class="input-group">
                    <label for="duration-input">Simulate for:</label>
                    <input type="number" id="duration-input" value="10" min="1">
                    <select id="duration-unit">
                        <option value="years">Years</option>
                        <option value="days">Days</option>
                    </select>
                </div>
            </div>
             
             <div class="disaster-config-section">
                <h3>Disaster Configuration</h3>
                <div class="disaster-grid">
                    <div class="disaster-card">
                        <h4>Drought</h4>
                        <div class="input-group"><label for="drought-chance">Chance (%):</label><input type="range" id="drought-chance" value="0" min="0" max="100"></div>
                        <div class="input-group"><label for="drought-area">Area (%):</label><input type="range" id="drought-area" value="30" min="10" max="100"></div>
                        <button class="trigger-button" id="trigger-drought">Trigger Drought</button>
                    </div>
                     <div class="disaster-card">
                        <h4>Forest Fire</h4>
                        <div class="input-group"><label for="fire-chance">Chance (%):</label><input type="range" id="fire-chance" value="0" min="0" max="100"></div>
                        <div class="input-group"><label for="fire-size">Initial Size:</label><input type="range" id="fire-size" value="50" min="10" max="200"></div>
                        <button class="trigger-button" id="trigger-fire">Trigger Fire</button>
                    </div>
                     <div class="disaster-card">
                        <h4>Poaching</h4>
                        <div class="input-group"><label for="poaching-chance">Chance (%):</label><input type="range" id="poaching-chance" value="0" min="0" max="100"></div>
                        <div class="input-group"><label for="poaching-num">Poachers:</label><input type="range" id="poaching-num" value="2" min="1" max="10"></div>
                        <div class="input-group"><label for="poaching-duration">Duration (days):</label><input type="range" id="poaching-duration" value="5" min="1" max="20"></div>
                        <button class="trigger-button" id="trigger-poaching">Trigger Poaching</button>
                    </div>
                     <div class="disaster-card">
                        <h4>Deforestation</h4>
                        <div class="input-group"><label for="deforestation-chance">Chance (%):</label><input type="range" id="deforestation-chance" value="0" min="0" max="100"></div>
                        <div class="input-group"><label for="deforestation-num">Deforesters:</label><input type="range" id="deforestation-num" value="2" min="1" max="10"></div>
                        <div class="input-group"><label for="deforestation-duration">Duration (days):</label><input type="range" id="deforestation-duration" value="5" min="1" max="20"></div>
                        <button class="trigger-button" id="trigger-deforestation">Trigger Deforestation</button>
                    </div>
                </div>
             </div>


            <div class="button-group">
                <button id="main-button">Start Simulation</button>
            </div>
        </div>
    </main>

    <script>
    // --- QuadTree, Point, Rectangle (No Changes) ---
    class Point { constructor(x, y, userData) { this.x = x; this.y = y; this.userData = userData; } }
    class Rectangle {
        constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
        contains(point) { return (point.x >= this.x - this.w && point.x <= this.x + this.w && point.y >= this.y - this.h && point.y <= this.y + this.h); }
        intersects(range) { return !(range.x - range.w > this.x + this.w || range.x + range.w < this.x - this.w || range.y - range.h > this.y + this.h || range.y + range.h < this.y - this.h); }
    }
    class QuadTree {
        constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.points = []; this.divided = false; }
        subdivide() {
            let { x, y, w, h } = this.boundary;
            let hw = w / 2, hh = h / 2;
            this.northeast = new QuadTree(new Rectangle(x + hw, y - hh, hw, hh), this.capacity); this.northwest = new QuadTree(new Rectangle(x - hw, y - hh, hw, hh), this.capacity);
            this.southeast = new QuadTree(new Rectangle(x + hw, y + hh, hw, hh), this.capacity); this.southwest = new QuadTree(new Rectangle(x - hw, y + hh, hw, hh), this.capacity);
            this.divided = true;
        }
        insert(point) {
            if (!this.boundary.contains(point)) return false;
            if (this.points.length < this.capacity) { this.points.push(point); return true; }
            if (!this.divided) this.subdivide();
            return this.northeast.insert(point) || this.northwest.insert(point) || this.southeast.insert(point) || this.southwest.insert(point);
        }
        query(range, found = []) {
            if (!this.boundary.intersects(range)) return found;
            for (let p of this.points) { if (range.contains(p)) found.push(p); }
            if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); }
            return found;
        }
    }

    // --- Animal (No Changes) ---
    class Animal {
        constructor(x, y, gender) {
            this.position = createVector(x, y);
            this.velocity = p5.Vector.random2D();
            this.acceleration = createVector();
            this.gender = gender;
            this.hunger = 0; this.matingUrge = 0; this.panic = 0;
            this.wanderTheta = random(TWO_PI);
            this.timeSpentHiding = 0;
            this.age = 0; 
            this.daysWithoutFood = 0;
        }

        isHungry() { return this.hunger > this.hungerThreshold; }
        isReadyToMate() { return this.matingUrge >= 100; }
        isHiding() { return this.timeSpentHiding > 0; }

        seek(targetVector, multiplier = 1) { let desired=p5.Vector.sub(targetVector,this.position); desired.setMag(this.maxSpeed * multiplier); return p5.Vector.sub(desired,this.velocity).limit(this.maxForce * multiplier); }
        flee(targetVector, multiplier = 1.5) { return this.seek(targetVector).mult(-multiplier); }
        wander() {
            let wanderPoint = this.velocity.copy(); wanderPoint.setMag(100); wanderPoint.add(this.position);
            let wanderRadius = 50, theta = this.wanderTheta + this.velocity.heading();
            let x = wanderRadius * cos(theta), y = wanderRadius * sin(theta);
            wanderPoint.add(x, y);
            let steer = p5.Vector.sub(wanderPoint, this.position); steer.setMag(this.maxForce);
            this.acceleration.add(steer); this.wanderTheta += random(-0.5, 0.5);
        }
        findClosest(qtree) {
            if (!qtree) return null;
            let searchArea = new Rectangle(this.position.x, this.position.y, this.searchRadius, this.searchRadius);
            let nearby = qtree.query(searchArea);
            let closest = null, closestDist = Infinity;
            for (let p of nearby) { let d=this.position.dist(p.userData.position); if (d < closestDist){closestDist=d; closest=p.userData;}}
            return closest;
        }
        
        applyBehaviors(preyQT, predatorQT, mates, hidingSpotsQT) {
             let closestPredator = this.findClosest(predatorQT);
             if (closestPredator) {
                let d = this.position.dist(closestPredator.position);
                this.panic = map(d, 0, this.searchRadius, 100, 20);
                this.timeSpentHiding++;

                let closestHidingSpot = this.findClosest(hidingSpotsQT);
                if (closestHidingSpot && this.timeSpentHiding < 120) { 
                    this.acceleration.add(this.seek(closestHidingSpot.position));
                } else {
                    this.acceleration.add(this.flee(closestPredator.position, map(this.panic,0,100,1,2.5)));
                }
             } else {
                this.panic = 0;
                this.timeSpentHiding = 0;
                
                if (this.isHungry()) { let target = this.findClosest(preyQT); if(target) this.acceleration.add(this.seek(target.position)); else this.wander(); }
                else if (this.isReadyToMate() && mates.length > 0) { this.acceleration.add(this.seek(mates[0].position)); }
                else { this.wander(); }
             }
        }
        
        updateStats() { 
            this.age++;
            this.hunger=min(100, this.hunger + this.hungerRate); 
            if (!this.isHungry()) {
                this.matingUrge = min(200, this.matingUrge + 100); 
                this.daysWithoutFood = 0;
            } else {
                this.daysWithoutFood++;
            }
        }
        update() { this.maxSpeed=this.baseMaxSpeed*speedMultiplier; this.maxForce=this.baseMaxForce*speedMultiplier; this.velocity.add(this.acceleration); this.velocity.limit(this.maxSpeed); this.position.add(this.velocity); this.acceleration.mult(0); this.boundaries(); }
        boundaries() { if (this.position.x < 0) this.position.x = worldWidth; if (this.position.x > worldWidth) this.position.x = 0; if (this.position.y < 0) this.position.y = worldHeight; if (this.position.y > worldHeight) this.position.y = 0; }
        
        displayState() {
            if (!showStatusBars) return;
            const barWidth = 25, barHeight = 4, spacing = 1;
            const x = this.position.x - barWidth / 2, y = this.position.y - this.size - (barHeight + spacing) * 3 - 2;
            const drawBar = (value, color, yOffset) => { push(); fill(50); noStroke(); rect(x,y+yOffset,barWidth,barHeight,1); let w=map(value,0,100,0,barWidth); fill(color); rect(x,y+yOffset,w,barHeight,1); pop(); };
            drawBar(this.panic, color(255,0,0), 0);
            drawBar(this.matingUrge, color(255,105,180), barHeight + spacing);
            drawBar(this.hunger, color(255,165,0), (barHeight + spacing) * 2);
        }
        displayHoverStats() {
            let m = screenToWorld(mouseX, mouseY);
            if (showStatusBars && dist(m.x, m.y, this.position.x, this.position.y) < this.size + 10) {
                push();
                fill(0,0,0,150); noStroke(); rect(this.position.x+15,this.position.y-30,80,45,5);
                fill(255); textSize(10); textAlign(LEFT, TOP);
                text(`P: ${floor(this.panic)}`, this.position.x+20, this.position.y-28);
                text(`M: ${floor(this.matingUrge)}`, this.position.x+20, this.position.y-18);
                text(`H: ${floor(this.hunger)}`, this.position.x+20, this.position.y-8);
                pop();
            }
        }
    }

    // --- Species (No Changes) ---
    class Plant { constructor(x, y) { this.position = createVector(x,y); this.size=random(5,15); } display() { noStroke(); fill(0,100,0); ellipse(this.position.x,this.position.y,this.size,this.size);}}
    class Butterfly extends Animal { constructor(x,y,g) { super(x,y,g); this.baseMaxSpeed=2; this.baseMaxForce=0.1; this.size=8; this.searchRadius=100; this.hungerRate=0; this.maxAge = 10;} isHungry() {return false;} display() { noStroke(); fill('pink'); ellipse(this.position.x, this.position.y, this.size, this.size); this.displayState(); this.displayHoverStats(); }}
    class Frog extends Animal { constructor(x,y,g) { super(x,y,g); this.baseMaxSpeed=2.5; this.baseMaxForce=0.2; this.size=12; this.searchRadius=120; this.hungerRate=15; this.hungerThreshold=50; this.maxAge=100; this.maxDaysWithoutFood = 12;} eat() {this.hunger=max(0, this.hunger-60);} display() { noStroke(); fill('darkgreen'); ellipse(this.position.x, this.position.y, this.size, this.size); this.displayState(); this.displayHoverStats(); }}
    class Snake extends Animal { constructor(x,y,g) { super(x,y,g); this.baseMaxSpeed=2; this.baseMaxForce=0.15; this.size=15; this.searchRadius=150; this.hungerRate=10; this.hungerThreshold=60; this.maxAge=200; this.maxDaysWithoutFood = 12;} eat(){this.hunger=max(0, this.hunger-80);} display() { push(); stroke('yellow'); strokeWeight(4); let dir=this.velocity.copy().normalize(); line(this.position.x,this.position.y,this.position.x-dir.x*this.size,this.position.y-dir.y*this.size); pop(); this.displayState(); this.displayHoverStats();}}
    class Hawk extends Animal { constructor(x,y,g) { super(x,y,g); this.baseMaxSpeed=3.5; this.baseMaxForce=0.25; this.size=12; this.searchRadius=250; this.hungerRate=5; this.hungerThreshold=70; this.maxAge=400; this.maxDaysWithoutFood = 12;} eat(){this.hunger=0;} display() { push(); translate(this.position.x,this.position.y); rotate(this.velocity.heading()+PI/2); noStroke(); fill('saddlebrown'); beginShape(); vertex(0, -this.size); vertex(-this.size/2, this.size); vertex(this.size/2, this.size); endShape(CLOSE); pop(); this.displayState(); this.displayHoverStats();}}

    // --- Disaster-related Humanoids ---
    class Humanoid {
        constructor(x, y, durationDays) {
            this.position = createVector(x, y);
            this.velocity = p5.Vector.random2D().mult(2);
            this.acceleration = createVector();
            this.size = 15;
            this.maxSpeed = 2;
            this.maxForce = 0.2;
            this.daysActive = 0;
            this.duration = durationDays;
        }
        
        seek(targetVector) { 
            let desired = p5.Vector.sub(targetVector, this.position);
            desired.setMag(this.maxSpeed);
            let steer = p5.Vector.sub(desired, this.velocity);
            steer.limit(this.maxForce);
            return steer;
        }

        update() {
            this.velocity.add(this.acceleration);
            this.velocity.limit(this.maxSpeed);
            this.position.add(this.velocity);
            this.acceleration.mult(0);
            this.boundaries();
        }
        boundaries() { 
            if (this.position.x < 0 || this.position.x > worldWidth || this.position.y < 0 || this.position.y > worldHeight) { 
                this.daysActive = this.duration; // Effectively remove them if they go off-screen
            } 
        }
        display() {
            push();
            fill(255, 100, 100);
            stroke(255,0,0);
            strokeWeight(2);
            ellipse(this.position.x, this.position.y, this.size, this.size);
            pop();
        }
    }

    class Poacher extends Humanoid {
        constructor(x, y, durationDays, targetType) {
            super(x, y, durationDays);
            this.targetType = targetType;
        }
        // Poachers just wander for now, they don't seek specific animals
    }
    
    class Deforester extends Humanoid {
        constructor(x, y, durationDays) {
            super(x, y, durationDays);
            this.searchRadius = 300;
        }

        applyBehaviors(plantsQT, treesQT) {
            let closest = this.findClosest(plantsQT, treesQT);
            if (closest) {
                let force = this.seek(closest.position);
                this.acceleration.add(force);
            }
        }

        findClosest(plantsQT, treesQT) {
            let searchArea = new Rectangle(this.position.x, this.position.y, this.searchRadius, this.searchRadius);
            let nearbyPlants = plantsQT.query(searchArea);
            let nearbyTrees = treesQT.query(searchArea);
            let nearby = [...nearbyPlants, ...nearbyTrees];

            let closest = null;
            let closestDist = Infinity;
            for (let p of nearby) {
                let d = this.position.dist(p.userData.position);
                if (d < closestDist) {
                    closestDist = d;
                    closest = p.userData;
                }
            }
            return closest;
        }
    }

    // --- Simulation ---
    // Core logic for running the simulation.
    function toggleSimulation() {
        isSimulating = !isSimulating;
        const triggerBtns = document.querySelectorAll('.trigger-button');
        if (isSimulating) {
            document.getElementById('main-button').innerHTML = 'Stop Simulation';
            triggerBtns.forEach(btn => btn.disabled = false);
            resetSimulation();
            loop();
        } else {
            document.getElementById('main-button').innerHTML = 'Start Simulation';
            triggerBtns.forEach(btn => btn.disabled = true);
            noLoop();
        }
    }
    function resetSimulation() {
        dayCounter=0; dayStartTime=millis(); dailyHistory=[];
        disasterState = { isDrought: false, droughtDays: 0, droughtCenter: null, droughtRadius: 0, 
                          isFire: false, fireDays: 0, fireCenter: null, fireRadius: 0,
                          poachers: [], deforesters: [] };
        setWorldSize();
        populations = { plants:[], butterflies:[], frogs:[], snakes:[], hawks:[] };
        const createPopulation=(arr,Cls,count)=>{for(let i=0;i<count;i++){let pos=getSafeSpawnPoint();arr.push(new Cls(pos.x,pos.y,i%2===0?'male':'female'));}};
        createPopulation(populations.plants,Plant,parseInt(initialInputs.plants.value));
        createPopulation(populations.butterflies,Butterfly,parseInt(initialInputs.butterflies.value));
        createPopulation(populations.frogs,Frog,parseInt(initialInputs.frogs.value));
        createPopulation(populations.snakes,Snake,parseInt(initialInputs.snakes.value));
        createPopulation(populations.hawks,Hawk,parseInt(initialInputs.hawks.value));
        generateEnvironment();
    }
    function runSimulationStep() {
        let qTrees = { hidingSpots: new QuadTree(new Rectangle(worldWidth/2,worldHeight/2,worldWidth/2,worldHeight/2), 4),
                       backgroundTrees: new QuadTree(new Rectangle(worldWidth/2,worldHeight/2,worldWidth/2,worldHeight/2), 4) };
        for (const item of backgroundTrees) {
            let p = new Point(item.position.x, item.position.y, item);
            qTrees.hidingSpots.insert(p);
            qTrees.backgroundTrees.insert(p);
        }
        for (const key in populations) { qTrees[key] = new QuadTree(new Rectangle(worldWidth/2,worldHeight/2,worldWidth/2,worldHeight/2), 4); for(const item of populations[key]) qTrees[key].insert(new Point(item.position.x, item.position.y, item)); }
        
        const findMates = (arr,self) => arr.filter(a => a.gender!==self.gender && a.isReadyToMate());
        
        let allPredators = [ ...populations.frogs, ...populations.snakes, ...populations.hawks, ...disasterState.poachers ];

        populations.butterflies.forEach(o => {o.applyBehaviors(qTrees.plants, qTrees.frogs, findMates(populations.butterflies,o), qTrees.hidingSpots); o.update();});
        populations.frogs.forEach(o => {o.applyBehaviors(qTrees.butterflies, qTrees.snakes, findMates(populations.frogs,o), qTrees.hidingSpots); o.update();});
        populations.snakes.forEach(o => {o.applyBehaviors(qTrees.frogs, qTrees.hawks, findMates(populations.snakes,o), qTrees.hidingSpots); o.update();});
        populations.hawks.forEach(o => {o.applyBehaviors(qTrees.snakes, null, findMates(populations.hawks,o), qTrees.hidingSpots); o.update();});
    
        // Update disaster agents
        disasterState.poachers.forEach(p => p.update());
        disasterState.deforesters.forEach(d => {
            d.applyBehaviors(qTrees.plants, qTrees.backgroundTrees);
            d.update();
        });
    }
    
    function handleInteractions() {
        const predation = (predators, prey) => {
            for (let i = predators.length - 1; i >= 0; i--) {
                if (!predators[i].isHungry() || predators[i].isHiding()) {
                    continue;
                }
                for (let j = prey.length - 1; j >= 0; j--) {
                    if (predators[i].position.dist(prey[j].position) < (predators[i].size + prey[j].size) / 2) {
                        prey.splice(j, 1);
                        if (predators[i].eat) { predators[i].eat(); }
                        break;
                    }
                }
            }
        };
        predation(populations.frogs, populations.butterflies);
        predation(populations.snakes, populations.frogs);
        predation(populations.hawks, populations.snakes);

        // Disaster Interactions
        handleDisasterInteractions();
    }

    const MATING_DISTANCE_THRESHOLD = 200;

    const simulateReproduction = (population, AnimalClass) => {
        const readyMales = population.filter(animal => animal.gender === 'male' && animal.isReadyToMate());
        const readyFemales = population.filter(animal => animal.gender === 'female' && animal.isReadyToMate());
        const numberOfPairings = Math.min(readyMales.length, readyFemales.length);
        const newOffspring = [];
        for (let i = 0; i < numberOfPairings; i++) {
            const male = readyMales[i];
            const female = readyFemales[i];
            if (male.position.dist(female.position) < MATING_DISTANCE_THRESHOLD) {
                const spawnPoint = getSafeSpawnPoint();
                const gender = Math.random() > 0.5 ? 'male' : 'female';
                newOffspring.push(new AnimalClass(spawnPoint.x, spawnPoint.y, gender));
                male.matingUrge -= 50;
                female.matingUrge -= 50;
            }
        }
        population.push(...newOffspring);
    };

    const spawnNewPlants = (plantPopulation, count) => {
        if(disasterState.isDrought) count = Math.floor(count / 4); // Less plants grow during drought
        for (let i = 0; i < count; i++) {
            const spawnPoint = getSafeSpawnPoint();
            plantPopulation.push(new Plant(spawnPoint.x, spawnPoint.y));
        }
    };

    const SIM_CONFIG = {
        PLANT_CULL_INTERVAL_DAYS: 30,
        PLANT_CULL_AMOUNT: 100,
        PLANT_CULL_MINIMUM: 100
    };

    const animalClassMap = { butterflies: Butterfly, frogs: Frog, snakes: Snake, hawks: Hawk };

    function updateAndCullAnimals(populations) {
        for (const species of Object.keys(animalClassMap)) {
            const population = populations[species];
            for (let i = population.length - 1; i >= 0; i--) {
                const animal = population[i];
                animal.updateStats?.(); 
                const isTooOld = animal.age > animal.maxAge;
                const hasStarved = animal.maxDaysWithoutFood && animal.daysWithoutFood > animal.maxDaysWithoutFood;
                if (isTooOld || hasStarved) {
                    population.splice(i, 1);
                }
            }
        }
    }

    function logDailyHistory() {
        const historyEntry = { day: dayCounter };
        for (const species of Object.keys(animalClassMap)) {
            historyEntry[species] = populations[species].length;
        }
        dailyHistory.push(historyEntry);
    }

    function findExtinctSpecies(populations) {
        for (const species of Object.keys(animalClassMap)) {
            if (populations[species].length === 0) {
                return species.charAt(0).toUpperCase() + species.slice(1);
            }
        }
        return null;
    }

    function handleExtinction(extinctSpecies, dayCounter) {
        if (isSimulating) {
            const infoDisplay = document.getElementById('info-display');
            infoDisplay.innerHTML = `Ecosystem collapsed on Day ${dayCounter}: ${extinctSpecies} went extinct.`;
            if (shouldDownloadCSV) { exportHistoryToCSV(); }
            toggleSimulation();
        }
    }
    
    function endOfDay() {
        dayCounter++;
        updateAndCullAnimals(populations);
        for (const [species, AnimalClass] of Object.entries(animalClassMap)) {
            if (populations[species]) { simulateReproduction(populations[species], AnimalClass); }
        }
        spawnNewPlants(populations.plants, SIM_CONFIG.NEW_PLANTS_PER_DAY);
        
        if (dayCounter % SIM_CONFIG.PLANT_CULL_INTERVAL_DAYS === 0 && populations.plants.length > SIM_CONFIG.PLANT_CULL_MINIMUM) {
            populations.plants.splice(0, SIM_CONFIG.PLANT_CULL_AMOUNT);
        }

        logDailyHistory();
        
        checkForDisasters();
        updateDisasters();

        const extinctSpecies = findExtinctSpecies(populations);
        if (extinctSpecies) { handleExtinction(extinctSpecies, dayCounter); }
    }
    
    // --- DISASTER LOGIC ---
    let disasterConfig = {};
    let disasterState = {
        isDrought: false,
        droughtDays: 0,
        droughtCenter: null,
        droughtRadius: 0,
        isFire: false,
        fireDays: 0,
        fireCenter: null,
        fireRadius: 0,
        poachers: [],
        deforesters: [],
    };

    function checkForDisasters() {
        if (random() * 100 < disasterConfig.drought.chance) startDrought();
        if (random() * 100 < disasterConfig.fire.chance) startFire();
        if (random() * 100 < disasterConfig.poaching.chance) startPoaching();
        if (random() * 100 < disasterConfig.deforestation.chance) startDeforestation();
    }

    function startDrought() {
        if(disasterState.isDrought) return;
        disasterState.isDrought = true;
        disasterState.droughtDays = 15;
        disasterState.droughtCenter = createVector(random(worldWidth), random(worldHeight));
        disasterState.droughtRadius = (max(worldWidth, worldHeight) / 2) * (disasterConfig.drought.area / 100);
        
        // Remove ponds within the drought area
        for (let i = ponds.length - 1; i >= 0; i--) {
            if (disasterState.droughtCenter.dist(ponds[i].position) < disasterState.droughtRadius) {
                ponds.splice(i, 1);
            }
        }
    }

    function startFire() {
        if(disasterState.isFire) return;
        disasterState.isFire = true;
        disasterState.fireDays = simMode === 'hyper' ? 20 : 5; // Longer duration in hyper mode
        disasterState.fireCenter = createVector(random(worldWidth), random(worldHeight));
        disasterState.fireRadius = disasterConfig.fire.size;
    }

    function startPoaching() {
        const numPoachers = disasterConfig.poaching.num;
        let duration = disasterConfig.poaching.duration;
        if (simMode === 'hyper') duration *= 4;
        const targetOptions = ['frogs', 'snakes', 'hawks'];
        const targetType = random(targetOptions);
        for (let i = 0; i < numPoachers; i++) {
            disasterState.poachers.push(new Poacher(random(worldWidth), random(worldHeight), duration, targetType));
        }
    }

    function startDeforestation() {
        const numDeforesters = disasterConfig.deforestation.num;
        let duration = disasterConfig.deforestation.duration;
        if (simMode === 'hyper') duration *= 4;
        for (let i = 0; i < numDeforesters; i++) {
            disasterState.deforesters.push(new Deforester(random(worldWidth), random(worldHeight), duration));
        }
    }

    function updateDisasters() {
        // Drought
        if (disasterState.isDrought) {
            disasterState.droughtDays--;
            if (disasterState.droughtDays <= 0) disasterState.isDrought = false;
        }

        // Fire
        if (disasterState.isFire) {
            disasterState.fireDays--;
            const maxFireRadius = min(worldWidth, worldHeight) / 2;
            disasterState.fireRadius = min(disasterState.fireRadius + 1, maxFireRadius);
            if (disasterState.fireDays <= 0) disasterState.isFire = false;
        }
        
        // Poachers & Deforesters
        disasterState.poachers.forEach(p => p.daysActive++);
        disasterState.deforesters.forEach(d => d.daysActive++);
        disasterState.poachers = disasterState.poachers.filter(p => p.daysActive < p.duration);
        disasterState.deforesters = disasterState.deforesters.filter(d => d.daysActive < d.duration);
    }
    
    function handleDisasterInteractions() {
        // Poaching
        for (const poacher of disasterState.poachers) {
            const targetPop = populations[poacher.targetType];
            if (!targetPop) continue;
            for (let i = targetPop.length - 1; i >= 0; i--) {
                if (poacher.position.dist(targetPop[i].position) < poacher.size) {
                    targetPop.splice(i, 1);
                    break; // Poacher gets one animal per frame
                }
            }
        }

        // Deforestation
        for (const deforester of disasterState.deforesters) {
            // Destroy trees on contact
            for (let i = backgroundTrees.length - 1; i >= 0; i--) {
                const tree = backgroundTrees[i];
                if (deforester.position.dist(tree.position) < (deforester.size + tree.size) / 2) {
                    backgroundTrees.splice(i, 1);
                }
            }
            // Destroy plants on contact
             for (let i = populations.plants.length - 1; i >= 0; i--) {
                const plant = populations.plants[i];
                if (deforester.position.dist(plant.position) < (deforester.size + plant.size) / 2) {
                    populations.plants.splice(i, 1);
                }
            }
        }

        // Fire
        if (disasterState.isFire) {
            const fire = disasterState;
            // Burn animals
            for (const species of Object.keys(animalClassMap)) {
                const population = populations[species];
                for (let i = population.length - 1; i >= 0; i--) {
                    const animal = population[i];
                    if (dist(fire.fireCenter.x, fire.fireCenter.y, animal.position.x, animal.position.y) < fire.fireRadius) {
                        population.splice(i, 1);
                    }
                }
            }
            // Burn plants
            for (let i = populations.plants.length - 1; i >= 0; i--) {
                const plant = populations.plants[i];
                if (dist(fire.fireCenter.x, fire.fireCenter.y, plant.position.x, plant.position.y) < fire.fireRadius) {
                    populations.plants.splice(i, 1);
                }
            }
            // Burn trees
            for (let i = backgroundTrees.length - 1; i >= 0; i--) {
                const tree = backgroundTrees[i];
                if (dist(fire.fireCenter.x, fire.fireCenter.y, tree.position.x, tree.position.y) < fire.fireRadius) {
                    backgroundTrees.splice(i, 1);
                }
            }
        }
    }


    // --- UI & Data Export ---
    let initialInputs = {};
    function initializeUI() {
        document.getElementById('main-button').addEventListener('click', toggleSimulation);
        
        const triggerBtns = document.querySelectorAll('.trigger-button');
        triggerBtns.forEach(btn => btn.disabled = true);

        document.getElementById('trigger-drought').addEventListener('click', startDrought);
        document.getElementById('trigger-fire').addEventListener('click', startFire);
        document.getElementById('trigger-poaching').addEventListener('click', startPoaching);
        document.getElementById('trigger-deforestation').addEventListener('click', startDeforestation);

        document.getElementById('mode-toggle').addEventListener('change', (e) => { simMode=e.target.checked?'hyper':'normal'; updateControlsView(); });
        document.getElementById('day-length-slider').addEventListener('input', (e) => { dayLengthMillis=e.target.value*1000; document.getElementById('day-length-value').innerHTML=e.target.value; speedMultiplier=10/e.target.value; });
        speedMultiplier=10/document.getElementById('day-length-slider').value;
        document.getElementById('status-toggle').addEventListener('click', (e) => { showStatusBars=!showStatusBars; e.target.classList.toggle('active',showStatusBars); e.target.innerHTML=showStatusBars?'Hide Status':'Show Status'; });
        document.getElementById('trees-toggle').addEventListener('click', (e) => { showBgTrees=!showBgTrees; e.target.classList.toggle('active',showBgTrees); e.target.innerHTML=showBgTrees?'Hide Trees':'Show Trees'; });
        initialInputs={plants:document.getElementById('initial-plants'),butterflies:document.getElementById('initial-butterflies'),frogs:document.getElementById('initial-frogs'),snakes:document.getElementById('initial-snakes'),hawks:document.getElementById('initial-hawks')};
        
        disasterConfig = {
            drought: {
                chance: document.getElementById('drought-chance').value,
                area: document.getElementById('drought-area').value
            },
            fire: {
                chance: document.getElementById('fire-chance').value,
                size: document.getElementById('fire-size').value
            },
            poaching: {
                chance: document.getElementById('poaching-chance').value,
                num: document.getElementById('poaching-num').value,
                duration: document.getElementById('poaching-duration').value
            },
            deforestation: {
                chance: document.getElementById('deforestation-chance').value,
                num: document.getElementById('deforestation-num').value,
                duration: document.getElementById('deforestation-duration').value
            }
        };

        document.getElementById('drought-chance').addEventListener('input', (e) => disasterConfig.drought.chance = e.target.value);
        document.getElementById('drought-area').addEventListener('input', (e) => disasterConfig.drought.area = e.target.value);
        document.getElementById('fire-chance').addEventListener('input', (e) => disasterConfig.fire.chance = e.target.value);
        document.getElementById('fire-size').addEventListener('input', (e) => disasterConfig.fire.size = e.target.value);
        document.getElementById('poaching-chance').addEventListener('input', (e) => disasterConfig.poaching.chance = e.target.value);
        document.getElementById('poaching-num').addEventListener('input', (e) => disasterConfig.poaching.num = e.target.value);
        document.getElementById('poaching-duration').addEventListener('input', (e) => disasterConfig.poaching.duration = e.target.value);
        document.getElementById('deforestation-chance').addEventListener('input', (e) => disasterConfig.deforestation.chance = e.target.value);
        document.getElementById('deforestation-num').addEventListener('input', (e) => disasterConfig.deforestation.num = e.target.value);
        document.getElementById('deforestation-duration').addEventListener('input', (e) => disasterConfig.deforestation.duration = e.target.value);
    }
    
    function updateControlsView() {
        const normalEl=document.getElementById('normal-controls'),hyperEl=document.getElementById('hyper-controls');
        if (simMode==='hyper'){normalEl.classList.add('hidden');hyperEl.classList.remove('hidden');}else{normalEl.classList.remove('hidden');hyperEl.classList.add('hidden');}
    }

    function updateInfoDisplay() {
        const infoEl=document.getElementById('info-display'); if(!infoEl)return; if(!isSimulating&&infoEl.innerHTML.includes("collapsed"))return;
        let p=populations,counts=`🌿:${p.plants.length} | 🦋:${p.butterflies.length} | 🐸:${p.frogs.length} | 🐍:${p.snakes.length} | 🦅:${p.hawks.length}`;
        let disasterText = "";
        if (disasterState.isDrought) disasterText += " DROUGHT!";
        if (disasterState.isFire) disasterText += " FIRE!";
        if (disasterState.poachers.length > 0) disasterText += " POACHING!";
        if (disasterState.deforesters.length > 0) disasterText += " DEFORESTATION!";
        
        if (simMode === 'hyper' && isSimulating) {
            const durationValue = parseInt(document.getElementById('duration-input').value);
            const durationUnit = document.getElementById('duration-unit').value;
            const totalDays = durationUnit === 'years' ? durationValue * 365 : durationValue;
            infoEl.innerHTML = `Simulating Day: ${dayCounter}/${totalDays} | ${counts}`;
        } else {
            infoEl.innerHTML = `Day: ${dayCounter} | ${counts}`;
        }
        infoEl.innerHTML += `<span style="color: var(--disaster-red);">${disasterText}</span>`;
    }

    function exportHistoryToCSV() {
        let csv="data:text/csv;charset=utf-8,Day,Butterflies,Frogs,Snakes,Hawks\n";
        dailyHistory.forEach(r=>{csv+=`${r.day},${r.butterflies},${r.frogs},${r.snakes},${r.hawks}\n`;});
        const link=document.createElement("a");link.setAttribute("href",encodeURI(csv));link.setAttribute("download","population_history.csv");document.body.appendChild(link);link.click();document.body.removeChild(link);
    }
    
    // --- Sketch & Camera ---
    let isSimulating=false,dayCounter=0,dayStartTime,populations={plants:[],butterflies:[],frogs:[],snakes:[],hawks:[]},simMode='normal',dayLengthMillis=10000,speedMultiplier=1,showStatusBars=false, showBgTrees=true, dailyHistory=[],ponds=[],backgroundTrees=[],riverPoints=[];
    let worldWidth, worldHeight;
    let camera = { x: 0, y: 0, zoom: 1 };
    let panStart = { x: 0, y: 0 };
    let isPanning = false;
    let shouldDownloadCSV = true;

    function setWorldSize() {
        const size = document.getElementById('map-size-select').value;
        if(size === 'small') { worldWidth = 1200; worldHeight = 800; }
        else if(size === 'large') { worldWidth = 2400; worldHeight = 1600; }
        else { worldWidth = 1800; worldHeight = 1200; }
        camera.x = worldWidth / 2;
        camera.y = worldHeight / 2;
    }

    function getSafeSpawnPoint() {
        let point, attempts = 0;
        do {
            point = createVector(random(worldWidth), random(worldHeight));
            attempts++;
        } while (isPosInWater(point, 15) && attempts < 100); 
        return point;
    }
    
    function isPosInWater(pos, buffer = 0) {
        for(const pond of ponds){if(pos.dist(pond.position)<pond.size.x/2 + buffer)return true;}
        return false;
    }

    function screenToWorld(x, y) { return { x: (x - width / 2) / camera.zoom + camera.x, y: (y - height / 2) / camera.zoom + camera.y }; }
    function generateEnvironment() {
        let numPonds;
        noiseSeed(millis());
        
        if (worldWidth === 1200) { numPonds = floor(random(1, 2)); }
        else if (worldWidth === 2400) { numPonds = floor(random(1, 4)); }
        else { numPonds = floor(random(1, 3)); }
        
        ponds = []; for(let i=0; i<numPonds; i++) {
            let p = { position: getSafeSpawnPoint(), size: {x: random(40,100), y: random(30,60)}, vertices: [] };
            let yoff_pond = random(100);
            for (let angle = 0; angle < TWO_PI; angle += 0.5) { let r = map(noise(yoff_pond), 0, 1, 0.8, 1.2); p.vertices.push(createVector(cos(angle) * (p.size.x/2 * r), sin(angle) * (p.size.y/2 * r))); yoff_pond += 0.2; }
            ponds.push(p);
        }
        backgroundTrees = []; let spacing = 75;
        for (let x = 0; x < worldWidth + spacing; x += spacing) {
            for (let y = 0; y < worldHeight + spacing; y += spacing) {
                let pos = createVector(x + random(-spacing/2, spacing/2), y + random(-spacing/2, spacing/2));
                if (!isPosInWater(pos, 20)) { 
                    backgroundTrees.push({position: pos, size: random(20,40), color: color(0,random(80,120),0)});
                }
            }
        }
    }
    
    function drawEnvironment() {
        // Draw normal ground
        background(10, 50, 10);
        
        // Draw drought area
        if (disasterState.isDrought) {
            push();
            fill(139, 69, 19, 150); // Brown, semi-transparent
            noStroke();
            ellipse(disasterState.droughtCenter.x, disasterState.droughtCenter.y, disasterState.droughtRadius * 2, disasterState.droughtRadius * 2);
            pop();
        }

        // Draw fire area
        if (disasterState.isFire) {
            push();
            fill(255, 0, 0, 100); // Red, semi-transparent
            noStroke();
            ellipse(disasterState.fireCenter.x, disasterState.fireCenter.y, disasterState.fireRadius * 2, disasterState.fireRadius * 2);
            pop();
        }

        ponds.forEach(p => { 
            push();
            translate(p.position.x, p.position.y);
            fill(65,105,225); noStroke();
            beginShape(); for (const v of p.vertices) vertex(v.x, v.y); endShape(CLOSE);
            pop();
        });
        if(showBgTrees){
             backgroundTrees.forEach(t => { noStroke(); fill(t.color); ellipse(t.position.x, t.position.y, t.size); });
        }
    }

    function setup() {
        let canvasContainer = select('#canvas-container'); let canvas = createCanvas(canvasContainer.width, 500); canvas.parent('canvas-container');
        let canvasEl = document.querySelector('#canvas-container canvas');
        canvasEl.addEventListener('mousedown', (e) => { isPanning=true; panStart.x = e.clientX; panStart.y = e.clientY; });
        canvasEl.addEventListener('mousemove', (e) => { if(isPanning){ camera.x -= (e.clientX-panStart.x)/camera.zoom; camera.y -= (e.clientY-panStart.y)/camera.zoom; panStart.x=e.clientX; panStart.y=e.clientY; }});
        canvasEl.addEventListener('mouseup', () => { isPanning = false; });
        canvasEl.addEventListener('mouseout', () => { isPanning = false; });
        canvasEl.addEventListener('wheel', (e) => { e.preventDefault(); let zoomFactor=0.001; let oldZoom=camera.zoom; camera.zoom -= e.deltaY * zoomFactor; camera.zoom = constrain(camera.zoom, 0.1, 5); let m=screenToWorld(mouseX,mouseY); camera.x = m.x + (camera.x - m.x) * (oldZoom/camera.zoom); camera.y = m.y + (camera.y - m.y) * (oldZoom/camera.zoom); });
        
        initializeUI(); updateControlsView(); noLoop();
    }

    function draw() {
        // Background is now handled in drawEnvironment to layer drought correctly
        
        translate(width/2, height/2); scale(camera.zoom); translate(-camera.x, -camera.y);
        
        drawEnvironment();
        
        noFill(); stroke(100); strokeWeight(2/camera.zoom); rect(0,0,worldWidth,worldHeight);
        
        if(isSimulating) {
            if (simMode === 'normal') {
                runSimulationStep(); 
                const timeElapsed = millis() - dayStartTime;
                if (timeElapsed > dayLengthMillis) { handleInteractions(); endOfDay(); dayStartTime = millis(); }
            } else { 
                const durationValue = parseInt(document.getElementById('duration-input').value);
                const durationUnit = document.getElementById('duration-unit').value;
                const totalDays = durationUnit === 'years' ? durationValue * 365 : durationValue;
                for(let i=0; i < 10; i++) { // Run 10 days per frame for speed
                    if(dayCounter >= totalDays || !isSimulating) { if(isSimulating) toggleSimulation(); break; }
                    runSimulationStep(); handleInteractions(); endOfDay();
                }
            }
        }
        
        Object.values(populations).flat().forEach(o=>o.display());
        disasterState.poachers.forEach(p => p.display());
        disasterState.deforesters.forEach(d => d.display());

        // Must be drawn after everything else so it's on top
        resetMatrix();
        updateInfoDisplay();
    }

    function windowResized() { resizeCanvas(select('#canvas-container').width, 500); }
    </script>
</body>
</html>
